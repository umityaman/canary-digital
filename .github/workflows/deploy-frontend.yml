name: Deploy Frontend to Cloud Run

on:
  push:
    branches:
      - main
    paths:
      - 'frontend/**'
      - '.github/workflows/deploy-frontend.yml'
  workflow_dispatch: # Manuel trigger için

# Prevent concurrent deployments
concurrency:
  group: deploy-frontend-${{ github.ref }}
  cancel-in-progress: false

env:
  PROJECT_ID: canary-digital-475319
  REGION: europe-west1
  SERVICE_NAME: canary-frontend
  BACKEND_URL: https://canary-backend-672344972017.europe-west1.run.app

jobs:
  deploy:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          # Deploy job runs `npm ci` at the repository root (workspaces);
          # use the root package-lock.json so cache keys match the install.
          cache-dependency-path: package-lock.json

      - name: Install Dependencies
        run: |
          echo "Installing npm workspaces at repository root"
          echo "Repo root: $(pwd)"
          echo "node: $(node -v) npm: $(npm -v)"
          npm ci --no-audit --prefer-offline || npm install --no-audit --prefer-offline

      - name: Google Auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Clean Build Artifacts Before Docker Build
        run: |
          cd frontend
          echo "Removing dist and .vite to ensure fresh build..."
          rm -rf dist
          rm -rf node_modules/.vite
          echo "Build artifacts cleaned"
      
      - name: Build Frontend
        run: |
          cd frontend
          echo "Building frontend with Vite..."
          npm run build
          echo "✅ Frontend build completed"
          ls -la dist/ || echo "❌ dist folder not found!"
      
      - name: Verify .dockerignore exists
        run: |
          cd frontend
          if [ ! -f .dockerignore ]; then
            echo "ERROR: .dockerignore not found!"
            exit 1
          fi
          echo ".dockerignore contents:"
          cat .dockerignore
          echo "Verified .dockerignore exists and excludes dist"

      - name: Build and Push Docker Image
        run: |
          cd frontend
          echo "Building Docker image directly (not using buildpacks)..."
          IMAGE_TAG="gcr.io/${{ env.PROJECT_ID }}/${{ env.SERVICE_NAME }}:${{ github.sha }}"
          
          # Build using our Dockerfile which includes cache cleaning
          # Note: VITE_API_URL is set as default ARG in Dockerfile
          # Use --suppress-logs to avoid VPC-SC log streaming errors
          gcloud builds submit \
            --tag "$IMAGE_TAG" \
            --project ${{ env.PROJECT_ID }} \
            --suppress-logs || \
          gcloud builds submit \
            --tag "$IMAGE_TAG" \
            --project ${{ env.PROJECT_ID }} \
            --async
          
          # Wait for build to complete (poll until SUCCESS or FAILURE)
          echo "Waiting for build to complete..."
          MAX_WAIT=600  # 10 minutes max
          ELAPSED=0
          INTERVAL=15
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            BUILD_STATUS=$(gcloud builds list --limit=1 --filter="images:$IMAGE_TAG" --format="value(status)" --project ${{ env.PROJECT_ID }})
            echo "Build status after ${ELAPSED}s: $BUILD_STATUS"
            
            if [ "$BUILD_STATUS" = "SUCCESS" ]; then
              echo "Build completed successfully!"
              break
            elif [ "$BUILD_STATUS" = "FAILURE" ] || [ "$BUILD_STATUS" = "CANCELLED" ] || [ "$BUILD_STATUS" = "TIMEOUT" ]; then
              echo "Build failed with status: $BUILD_STATUS"
              exit 1
            fi
            
            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done
          
          if [ "$BUILD_STATUS" != "SUCCESS" ]; then
            echo "Build timed out after ${MAX_WAIT}s with status: $BUILD_STATUS"
            exit 1
          fi
          
          echo "Image built: $IMAGE_TAG"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        id: build

      - name: Deploy to Cloud Run
        run: |
          echo "Deploying Docker image to Cloud Run..."
          gcloud run deploy ${{ env.SERVICE_NAME }} \
            --image=${{ steps.build.outputs.image_tag }} \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --min-instances=0 \
            --max-instances=10 \
            --memory=512Mi \
            --cpu=1 \
            --port=8080 \
            --timeout=300

      - name: Get Service URL
        id: get-url
        run: |
          URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "Frontend deployed to: $URL"

      - name: Health Check
        run: |
          sleep 10
          curl -f ${{ steps.get-url.outputs.url }} || exit 1

      - name: Verify Bundle Hash Change
        run: |
          echo "Verifying new bundle was deployed..."
          RESPONSE=$(curl -s ${{ steps.get-url.outputs.url }})
          BUNDLE=$(echo "$RESPONSE" | grep -oP 'index-[a-zA-Z0-9_-]+\.js' | head -1)
          
          if [ -z "$BUNDLE" ]; then
            echo "❌ ERROR: Could not find main JS bundle in HTML"
            exit 1
          fi
          
          echo "✅ Main JS Bundle: $BUNDLE"
          
          # Store bundle hash for future reference
          echo "bundle_hash=$BUNDLE" >> $GITHUB_OUTPUT
          
          # Verify bundle is accessible
          BUNDLE_URL="${{ steps.get-url.outputs.url }}/assets/$BUNDLE"
          if curl -f -s "$BUNDLE_URL" > /dev/null; then
            echo "✅ Bundle is accessible at: $BUNDLE_URL"
          else
            echo "❌ ERROR: Bundle not accessible at: $BUNDLE_URL"
            exit 1
          fi

      - name: Smoke Test - Report Pages
        run: |
          echo "Running smoke tests for report pages..."
          URL="${{ steps.get-url.outputs.url }}"
          
          # Test 1: Main page loads
          if curl -f -s "$URL" > /dev/null; then
            echo "✅ Main page loads successfully"
          else
            echo "❌ Main page failed to load"
            exit 1
          fi
          
          # Test 2: Check for critical assets
          RESPONSE=$(curl -s "$URL")
          
          if echo "$RESPONSE" | grep -q "index.*\.css"; then
            echo "✅ CSS bundle found"
          else
            echo "⚠️  Warning: CSS bundle not found"
          fi
          
          if echo "$RESPONSE" | grep -q "AdvancedReporting"; then
            echo "✅ AdvancedReporting component chunk found"
          else
            echo "✅ AdvancedReporting (lazy-loaded component - OK if not in HTML)"
          fi
          
          echo "✅ Smoke tests passed"

      - name: Deployment Success Notification
        if: success()
        run: |
          echo "✅ Frontend deployment successful!"
          echo "URL: ${{ steps.get-url.outputs.url }}"
          echo "Deployment timestamp: $(date)"

      - name: Deployment Failure Notification
        if: failure()
        run: |
          echo "❌ Frontend deployment failed!"
          exit 1
