name: Full Deployment (Backend + Frontend)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  PROJECT_ID: canary-digital-475319
  REGION: europe-west1

jobs:
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    outputs:
      backend-url: ${{ steps.get-backend-url.outputs.url }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Google Auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install workspace dependencies (root, debug)
        run: |
          echo "Running npm ci at repository root to install workspaces"
          echo "Repo root: $(pwd)"
          echo "node version:"; node -v || true
          echo "npm version:"; npm -v || true
          echo "Listing repo root (head):";
          ls -la || true
          echo "package.json (root - head):";
          sed -n '1,200p' package.json || true
          echo "package-lock.json (root - head):";
          head -n 50 package-lock.json || true
          echo "Running npm ci...";
          npm ci --no-audit --prefer-offline

      - name: Generate Prisma client (debug)
        run: |
          cd backend
          echo "Working dir: $(pwd)"
          echo "Prisma schema path: prisma/schema.prisma"
          if [ -f prisma/schema.prisma ]; then
            echo "schema.prisma exists; showing head..."
            sed -n '1,200p' prisma/schema.prisma || true
          else
            echo "schema.prisma not found, listing prisma directory:";
            ls -la prisma || true
          fi
          echo "Listing backend node_modules (partial) if exists..."
          ls -la node_modules | head -n 50 || true
          echo "Running npx prisma generate..."
          npx prisma generate --schema=prisma/schema.prisma

      - name: Deploy Backend to Cloud Run
        run: |
          cd backend
          gcloud run deploy canary-backend \
            --source . \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --min-instances=0 \
            --max-instances=10 \
            --memory=1Gi \
            --cpu=1 \
            --port=4000 \
            --timeout=300 \
            --set-cloudsql-instances=${{ env.PROJECT_ID }}:${{ env.REGION }}:canary-postgres \
            --update-secrets=JWT_SECRET=jwt-secret:latest \
            --update-secrets=JWT_REFRESH_SECRET=jwt-secret:latest \
            --update-secrets=DATABASE_URL=database-url:latest \
            --set-env-vars="NODE_ENV=production"

      - name: Get Backend URL
        id: get-backend-url
        run: |
          # Use hardcoded stable backend URL instead of dynamic retrieval
          URL="https://canary-backend-672344972017.europe-west1.run.app"
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "Backend URL: $URL"

      - name: Backend Health Check
        run: |
          sleep 15
          curl -f ${{ steps.get-backend-url.outputs.url }}/api/health || exit 1

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: deploy-backend
    # Do not use job-level working-directory (it caused npm ci to run inside subfolder
    # and fail for npm workspaces). We'll run installs at repo root and explicitly cd
    # into frontend for build steps.
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install Dependencies (root workspaces)
        run: |
          echo "Installing npm workspaces at repository root"
          echo "Repo root: $(pwd)"
          echo "node: $(node -v) npm: $(npm -v)"
          # Install workspace packages from root so npm ci can respect the root lockfile
          npm ci --no-audit --prefer-offline || npm install --no-audit --prefer-offline

      - name: Google Auth
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}

      - name: Build Frontend with VITE_API_URL
        env:
          VITE_API_URL: ${{ needs.deploy-backend.outputs.backend-url }}/api
        run: |
          echo "Building with VITE_API_URL=$VITE_API_URL"
          cd frontend
          npm run build
          echo "Build complete - dist folder ready"
          ls -la dist/

      - name: Prepare Frontend for deployment
        run: |
          cd frontend
          # Backup original Dockerfile
          cp Dockerfile Dockerfile.original
          # Create simple Dockerfile for pre-built dist
          cat > Dockerfile << 'EOF'
          FROM nginx:alpine
          COPY dist /usr/share/nginx/html
          COPY nginx.conf /etc/nginx/conf.d/default.conf
          EXPOSE 8080
          CMD ["nginx", "-g", "daemon off;"]
          EOF
          
      - name: Deploy Frontend to Cloud Run
        run: |
          cd frontend
          gcloud run deploy canary-frontend \
            --source . \
            --region=${{ env.REGION }} \
            --platform=managed \
            --allow-unauthenticated \
            --min-instances=0 \
            --max-instances=10 \
            --memory=256Mi \
            --cpu=1 \
            --port=8080

      - name: Get Frontend URL
        id: get-frontend-url
        run: |
          URL=$(gcloud run services describe canary-frontend \
            --region=${{ env.REGION }} \
            --format='value(status.url)')
          echo "url=$URL" >> $GITHUB_OUTPUT
          echo "Frontend URL: $URL"

      - name: Frontend Health Check
        run: |
          sleep 10
          curl -f ${{ steps.get-frontend-url.outputs.url }} || exit 1

      - name: Update Backend CORS
        run: |
          # Backend'e frontend URL'ini CORS'a ekle
          echo "Updating backend CORS with frontend URL: ${{ steps.get-frontend-url.outputs.url }}"

  notify-success:
    name: Deployment Success
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: success()
    
    steps:
      - name: Success Notification
        run: |
          echo "🎉 Full deployment successful!"
          echo "Backend: ${{ needs.deploy-backend.outputs.backend-url }}"
          echo "Frontend: Check Cloud Run console"

  post-deploy-smoke:
    name: Post-deploy smoke tests
    runs-on: ubuntu-latest
    needs: deploy-frontend
    continue-on-error: true
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run login and save token
        env:
          BASE_URL: ${{ needs.deploy-backend.outputs.backend-url }}
          SMOKE_USER: ${{ secrets.SMOKE_USER }}
          SMOKE_PASS: ${{ secrets.SMOKE_PASS }}
        run: |
          # Write a PowerShell script using a single-quoted here-doc to avoid Bash
          # interpolating $variables (which caused the parser error).
          cat > login-smoke.ps1 <<'PS1'
          $ErrorActionPreference = 'Stop'
          Write-Output 'Attempting login for smoke test...'
          # If BASE_URL is empty for any reason, fall back to a known stable URL so the smoke
          # job can still run while we investigate why the output wasn't propagated.
          if (-not $env:BASE_URL -or $env:BASE_URL -eq '') {
            Write-Output 'BASE_URL is empty; falling back to stable backend URL'
            $env:BASE_URL = 'https://canary-backend-672344972017.europe-west1.run.app'
          } else {
            Write-Output "Using BASE_URL=$env:BASE_URL"
          }
          $body = @{ email = $env:SMOKE_USER; password = $env:SMOKE_PASS } | ConvertTo-Json
          # Use PowerShell expansion of environment variable inside the script
          # Retry login up to 3 times with exponential backoff
          $resp = $null
          for ($i = 1; $i -le 3; $i++) {
            try {
              $resp = Invoke-RestMethod -Uri "$($env:BASE_URL)/api/auth/login" -Method Post -ContentType 'application/json' -Body $body -ErrorAction Stop
              break
            } catch {
              Write-Output "Login attempt $i failed: $($_.Exception.Message)"
              if ($i -lt 3) { Start-Sleep -Seconds (5 * $i) } else {
                # on final failure, try to save response body for debugging then exit
                try {
                  if ($_.Exception.Response) {
                    $stream = $_.Exception.Response.GetResponseStream()
                    $sr = New-Object System.IO.StreamReader($stream)
                    $bodyText = $sr.ReadToEnd()
                    $bodyText | Out-File -FilePath login-response-body.txt -Encoding utf8
                    Write-Output 'Saved login response body to login-response-body.txt'
                  }
                } catch { }
                Write-Output 'Login failed after 3 attempts'; exit 1
              }
            }
          }

          # If login succeeded, extract token and save sanitized login response (no token)
          if ($null -ne $resp) {
            $token = $null
            if ($null -ne $resp.token) { $token = $resp.token } elseif ($null -ne $resp.accessToken) { $token = $resp.accessToken } elseif ($null -ne $resp.data -and $null -ne $resp.data.accessToken) { $token = $resp.data.accessToken } elseif ($null -ne $resp.data -and $null -ne $resp.data.token) { $token = $resp.data.token }
            if ($token) { $token | Out-File -FilePath login-token.txt -Encoding utf8; Write-Output 'Token saved to login-token.txt' } else { Write-Output 'No token in login response'; exit 1 }
            # Save sanitized login response without token for debugging
            $safe = @{}
            if ($resp.PSObject.Properties['message']) { $safe.message = $resp.message }
            if ($resp.PSObject.Properties['user']) { $safe.user = $resp.user }
            $safe | ConvertTo-Json -Depth 6 | Out-File -FilePath login-response.json -Encoding utf8
          } else {
            Write-Output 'Login response missing after retries'; exit 1
          }
          PS1
          pwsh -NoProfile -ExecutionPolicy Bypass -File ./login-smoke.ps1

      - name: Run extended smoke script
        run: |
          # Use Unix-style path on Linux runners (bash) — backslashes were being removed
          # resulting in a malformed script path like '.scriptssmoke-extended3.ps1'.
          pwsh -NoProfile -ExecutionPolicy Bypass -File ./scripts/smoke-extended3.ps1

      - name: Verify PDF hashes
        run: |
          set -e
          echo "Verifying pdf-hashes.txt against downloaded invoice-*.pdf files"
          if [ ! -f pdf-hashes.txt ]; then echo "pdf-hashes.txt not found"; exit 2; fi
          while IFS= read -r line || [ -n "$line" ]; do
            # pdf-hashes.txt lines are: <HEX>  <filename>
            hash=$(echo "$line" | awk '{print $1}')
            file=$(echo "$line" | awk '{print $2}')
            if [ ! -f "$file" ]; then echo "Missing expected file: $file"; exit 3; fi
            calc=$(sha256sum "$file" | awk '{print $1}' | tr '[:lower:]' '[:upper:]')
            expected=$(echo "$hash" | tr '[:lower:]' '[:upper:]')
            if [ "$calc" != "$expected" ]; then echo "Hash mismatch for $file: expected $expected got $calc"; exit 4; fi
            echo "Verified $file"
          done < pdf-hashes.txt
          echo "All PDF hashes verified"
          # Extra verification: ensure pdf-results.json reports all downloads as success
          if [ -f pdf-results.json ]; then
            if grep -E '"success"\s*:\s*false' -q pdf-results.json; then
              echo "One or more PDF downloads failed according to pdf-results.json"; exit 5
            fi
            if grep -E '"savedFile"\s*:\s*null' -q pdf-results.json; then
              echo "One or more pdf-results.json entries have null savedFile"; exit 6
            fi
            echo "pdf-results.json verification passed"
          else
            echo "pdf-results.json not present; skipping results verification"
          fi

      - name: Upload smoke artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-artifacts
          path: |
            invoices.json
            invoice-*.pdf
            pdf-hashes.txt
            pdf-missing.txt
            pdf-results.json
            smoke-extended-pdf-error-body-*.txt
            login-response.json
            smoke-extended-log.txt
            health-result-*.json
            smoke-extended-error.txt
            smoke-extended-pdf-error-body.txt

  notify-failure:
    name: Deployment Failure
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: failure()
    
    steps:
      - name: Failure Notification
        run: |
          echo "❌ Deployment failed!"
          echo "Check the logs for details"
          exit 1
